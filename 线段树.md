---
title: 线段树
tags: 数据结构,模板,线段树
grammar_cjkRuby: true
---


线段树简单运用
[例题](https://www.luogu.org/problemnew/show/P1816)
注意建树方法和递归边界
```cpp?linenums
#include<cstdio>
#define MAXN 100005
#define min(a,b) (a < b ? a : b)
#define INF 0x3f3f3f3f
using namespace std;
typedef long long ll;
int read(){
	char c = getchar();
	bool flag = true;
	while(c < '0' || '9' < c){
		if(c == '-')
			flag = false;
		c = getchar();
	}
	int x = 0;
	while('0' <= c && c <= '9'){
		x = 10 * x + c - '0';
		c = getchar();
	}
	return flag ? x : -x;
}
int n,m;
ll a[MAXN],minv[MAXN << 2];

void pushup(int o){
	minv[o] = min(minv[o << 1] , minv[(o << 1) + 1]);
}
int ql,qr;
ll query(int o,int L,int R){
	if(ql <= L && R <= qr)
		return minv[o];//当查询区间已经包含了该区间 
	int M = (L + R) >> 1;
	ll ans = INF;
	if(ql <= M)
		ans = min(ans,query(o << 1,L,M));
	if(M < qr)
		ans = min(ans,query((o << 1) + 1,M + 1,R));//注意范围 
	return ans;
}

int p,v;//要修改的地址和要修改的值 
void change(int o,int L,int R){
	if(L == R)
		minv[o] = v;
	else{
		int M = (L + R) >> 1;
		if(p <= M)
			change(o << 1,L,M);
		if(M < p)
			change((o << 1) + 1,M + 1,R);//注意这里的范围 
		pushup(o);
	}
}

void build(int o,int L,int R){
	if(L == R){//当只有单点时候直接更新 
		minv[o] = a[L];
		return;
	}
	int M = (L + R) >> 1;
	build(o << 1,L,M);//递归左子树 
	build((o << 1) + 1,M + 1,R);//递归右子树 
	pushup(o);//往上更新 
} 

int main(){
	n = read();
	m = read();
	for(int i = 1;i <= n;i++){
		//p = i,v = read();
		//change(1,1,n);修改建树 
		a[i] = read();
	}
	build(1,1,n);//递归建树 
	for(int i = 1;i <= m;i++){
		ql = read();
		qr = read();
		printf("%d ",query(1,1,n));
	}
	return 0;
} 
```