---
title: 2018-10-18状压DP笔记
tags: DP,状态压缩,状压DP
grammar_cjkRuby: true
---
[例题1 玉米田Corn Fields](https://www.luogu.org/problemnew/show/P1879)

这道题说的是**没有哪两块草地有公共边**,这就是我们DP的时候要注意的条件

状态转移方程比较简单

>**f[i][j] += f[i - 1][k]**
其中是第行的状态，k是第i - 1行的状态
并且要j状态中彼此互不相邻，j与k对应位上互不相等

1.首先是上面一条和下面一条的判断

```cpp
if(!(k & j)){//把k和j对于位进行和运算，如果为0就是对应位不相等
```

2.其次是自己状态的互不相邻

```cpp
if(x & (x << 1))//判断自己是不是互不相交
```
还有就是要初始化f[0][0] = 1

```cpp
#include<cstdio>
#define MOD 100000000
int n,m;
bool a[15][15];
int read(){
	char c = getchar();
	while(c < '0' || '9' < c){
		c = getchar();
	}
	int x = 0;
	while('0' <= c && c <= '9'){
		x = 10 * x + c - '0';
		c = getchar();
	}
	return x;
}
int f[13][1 << 12];

bool check(int k,int x){
	for(int i = 1;i <= n;i++){
		if((!a[k][i]) && (1 << (i - 1)) & x)//当这个地方不能放的时候 
			return false;
	}
	if(x & (x << 1))//判断自己是不是互不相交 
		return false; 
	return true;
}

int main(){
	scanf("%d%d",&m,&n);
	for(int i = 1;i <= m;i++)
		for(int j = 1;j <= n;j++){
			a[i][j] = read();
		}
	f[0][0] = 1;
	for(int i = 1;i <= m;i++){
		for(int j = 0;j <= (1 << n) - 1;j++){
			if(check(i,j)){
				for(int k = 0;k <= (1 << n) - 1;k++){//枚举上一维的状态 
					if(!(k & j)){//把k和j对于位进行和运算，如果为0就是不想交 
						f[i][j] = (f[i][j] + f[i - 1][k]) % MOD;
					}
				}
			}
		}
	}
	long long ans = 0;
	for(int i = 0;i <= (1 << n) - 1;i++)
		ans += f[m][i];
	printf("%lld\n",ans % MOD);
	return 0;
}
```