---
title: 2018-10-10欧拉回路Luogu2731
tags: 图论
grammar_cjkRuby: true
---


>John是一个与其他农民一样懒的人。他讨厌骑马，因此从来不两次经过一个栅栏。你必须编一个程序，读入栅栏网络的描述，并计算出一条修栅栏的路径，使每个栅栏都恰好被经过一次。John能从任何一个顶点(即两个栅栏的交点)开始骑马，在任意一个顶点结束。

>每一个栅栏连接两个顶点，顶点用1到500标号(虽然有的农场并没有500个顶点)。一个顶点上可连接任意多(>=1)个栅栏。两顶点间可能有多个栅栏。所有栅栏都是连通的(也就是你可以从任意一个栅栏到达另外的所有栅栏)。

>你的程序必须输出骑马的路径(用路上依次经过的顶点号码表示)。我们如果把输出的路径看成是一个500进制的数，那么当存在多组解的情况下，输出500进制表示法中最小的一个 (也就是输出第一位较小的，如果还有多组解，输出第二位较小的，等等)。

***==无向图==***

首先，在无向图中，要确定是否存在欧拉回路很容易：只要每个点的度数均为偶数即可。（这里就不扯什么连不连通的鬼东西了）。 
因为每个点的度数为偶数，所以可以将整个图看做由数个环嵌套而成，因为环一定能找到一条欧拉回路，所以整个图也能找到欧拉回路。 

 ![](./images/1539155528244.png)
 
欧拉路径：如果有且仅有两个点的度数为奇数，就会存在一条从这两个中的一个到达另一个的欧拉路径。 
假如在这两个点间连一条边，就能够从任意一个点出发找到一条欧拉回路，当出发点为这两个点中的一个时，切断这条边，就成为一条欧拉路径了。 

![](./images/1539155556573.png)


***==有向图==***

欧拉回路：所有点的入度等于出度，就存在一条欧拉回路。 
这里可以换一种角度来理解，对于每一个点，每次进入这个节点，就一定有一条路可以出去，因此必定存在一条欧拉回路。 
欧拉路径：最多有一点入度等于出度+1，最多有一点入度等于出度-1，就会有一条从出度大于入度（没有则等于）的点出发，到达出度小于入度（没有则等于）的点的一条欧拉路径。证明方法与无向图的欧拉路径类似。

**对于求欧拉回路的问题，有Fluery算法和Hierholzers算法，两种算法。**

后面一种算法无论是编程复杂度还是时间复杂度好像都比前种算法复杂度更优，但前者的应用广泛性好像比后者更高。

>对于Hierholzers算法，前提是假设图G存在欧拉回路，即有向图任意 点的出度和入度相同。从任意一个起始点v开始遍历，直到再次到达 点v，即寻找一个环，这会保证一定可以到达点v，因为遍历到任意一 个点u，由于其出度和入度相同，故u一定存在一条出边，所以一定可 以到达v。将此环定义为C，如果环C中存在某个点x，其有出边不在环 中，则继续以此点x开始遍历寻找环C’，将环C、C’连接起来也是一个 大环，如此往复，直到图G中所有的边均已经添加到环中。


参考代码，如下，需要注意的是这道题是说可以有重边，所有开始写的代码不太对

~~~cpp
#include<cstdio>
#include<stack>
#define max(a,b) (a > b ? a : b)
using namespace std;
int read(){
	char c = getchar();
	while(c < '0' || '9' < c)
		c = getchar();
	int x = 0;
	while('0' <= c && c <= '9'){
		x = 10 * x + c - '0';
		c = getchar();
	}
	return x;
}
int f,x,y,d[505],k,p1,G[505][505];
stack<int> s;

void dfs(int u){
	for(int v = 1;v <= k;v++){
		if(G[u][v]){
			G[u][v]--;G[v][u]--;
			dfs(v);
		}
	}
	s.push(u);
}

int main(){
	//freopen("testdata.in","r",stdin);
	//freopen("testdata.out","w",stdout);
	f = read();
	for(int i = 1;i <= f;i++){
		x = read();y = read();
		G[x][y]++;G[y][x]++;
		d[x]++;d[y]++;
		k = max(k,max(x,y));
	}
	p1 = 1;
	for(int i = 1;i <= k;i++){
		if(d[i] % 2){
			p1 = i;
			break; 
		}
	}
	dfs(p1);
	while(!s.empty()){
		printf("%d\n",s.top());
		s.pop();
	}
	return 0;
} 
~~~