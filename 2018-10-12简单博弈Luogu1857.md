---
title: 2018-10-12简单博弈Luogu1857
tags: 数学,博弈论
grammar_cjkRuby: true
---


``` cpp
#include<cstdio>
#include<cstring>
#define N 20005
#define min(a,b) (a < b ? a : b)
#define max(a,b) (a > b ? a : b)
using namespace std;
int v[20005],prime[3000],p,f[20005],g[20005],n,tot;
bool tong[20005];
int read(){
	char c = getchar();
	while(c < '0' || '9' < c)
		c = getchar();
	int x = 0;
	while('0' <= c && c <= '9'){
		x = 10 * x + c - '0';
		c = getchar();
	}
	return x;
}

int main(){
	memset(f,-1,sizeof(f));
	memset(g,0,sizeof(g));
	for(int i = 2;i <= N;i++){//筛选素数 
		if(!v[i]){
			v[i] = i;
			prime[++p] = i;
		}
		for(int j = 0;j <= p;j++){
			if(v[i] < prime[j] || prime[j] * i > N)
				break;
			v[i * prime[j]] = i;
		}
	}
	g[0] = g[1] = 0;//必败态0,1移动最少步数为0 
	for(int i = 2;i <= N;i++){
		for(int j = p;j >= 1;j--){
			if(prime[j] <= i){
				if(f[i - prime[j]] == -1){//前面某一个状态为必败态，则这个状态就是必胜态，并且需要记录最少胜利的次数
					if(f[i] == -1){
						f[i] = 0x3f3f3f3f;
					}
					f[i] = min(f[i],g[i - prime[j]] + 1);
				}
			}
		}
		if(f[i] == -1){//如果这个点是必败点，那么就要算如何败是最快的
			for(int j = p;j >= 1;j--){
				if(prime[j] <= i && f[i - prime[j]] > 0){
					g[i] = max(g[i],f[i - prime[j]] + 1);
				}
			}
		}
	}
	/*
	for(int i = 0;i <= N;i++){
		if(!tong[f[i]]){
			tong[f[i]] = true;
			tot++;
		}
	}
	printf("%d\n",tot);
	*/
		//printf("%d\n",f[i]);
	n = read();
	for(int i = 1;i <= n;i++){
		int x = read();
		printf("%d\n",f[x]);
	}
	return 0;
}
```